
APDS9960_Proximity.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000004d6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000462  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000001  00800100  00800100  000004d6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000004d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000508  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001b8  00000000  00000000  00000548  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000218c  00000000  00000000  00000700  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000434  00000000  00000000  0000288c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000610  00000000  00000000  00002cc0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003f0  00000000  00000000  000032d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000c2a  00000000  00000000  000036c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000e01  00000000  00000000  000042ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000198  00000000  00000000  000050eb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
   4:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
   8:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
   c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  10:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__vector_4>
  14:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  18:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  1c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  20:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  24:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  28:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  2c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  30:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  34:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  38:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  3c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  40:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  44:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  48:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  4c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  50:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  54:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  58:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  5c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  60:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  64:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  68:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  6c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  70:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  74:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  78:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  7c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  80:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  84:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  88:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  8c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  90:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  94:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  98:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  9c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a0:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a4:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a8:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	da e0       	ldi	r29, 0x0A	; 10
  b4:	de bf       	out	0x3e, r29	; 62
  b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_clear_bss>:
  b8:	21 e0       	ldi	r18, 0x01	; 1
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b1 e0       	ldi	r27, 0x01	; 1
  be:	01 c0       	rjmp	.+2      	; 0xc2 <.do_clear_bss_start>

000000c0 <.do_clear_bss_loop>:
  c0:	1d 92       	st	X+, r1

000000c2 <.do_clear_bss_start>:
  c2:	a1 30       	cpi	r26, 0x01	; 1
  c4:	b2 07       	cpc	r27, r18
  c6:	e1 f7       	brne	.-8      	; 0xc0 <.do_clear_bss_loop>
  c8:	0e 94 b6 01 	call	0x36c	; 0x36c <main>
  cc:	0c 94 2f 02 	jmp	0x45e	; 0x45e <_exit>

000000d0 <__bad_interrupt>:
  d0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d4 <_ZN12APDS9960_AVRC1Ev>:


#include "APDS9960_AVR.h"
#include <avr/io.h>

APDS9960_AVR::APDS9960_AVR()
  d4:	fc 01       	movw	r30, r24
	//DDRD &= ~((1<<DDD0) | (1<<DDD1));		//activate Pins for SDA and SCL function
	//PORTD &= ~((1<<PD0) | (1<<PD1));			//activate internal pull-ups
	
	// initialize TWI clock: 
	
	TWSR &= ~((1 << TWPS1) | (1 << TWPS0));								// no prescaler 
  d6:	a9 eb       	ldi	r26, 0xB9	; 185
  d8:	b0 e0       	ldi	r27, 0x00	; 0
  da:	8c 91       	ld	r24, X
  dc:	8c 7f       	andi	r24, 0xFC	; 252
  de:	8c 93       	st	X, r24
	TWBR = ((16000000UL/SCL_CLOCK)-16)/2;  // must be > 10 for stable operation 
  e0:	8c e0       	ldi	r24, 0x0C	; 12
  e2:	80 93 b8 00 	sts	0x00B8, r24
	
	//Initialize Errorcode LED
	/*DDRF |= (1<<DDF0);*/
	
	//and Error Flag
	error_i2c = false;
  e6:	10 82       	st	Z, r1
	
	//Initialize all class members
	enable = 0;
  e8:	11 82       	std	Z+1, r1	; 0x01
	status = 0;
  ea:	12 82       	std	Z+2, r1	; 0x02
	
	pers= 0;
  ec:	13 82       	std	Z+3, r1	; 0x03
	pulseCount = 0;
  ee:	14 82       	std	Z+4, r1	; 0x04
	controlOne = 0;
  f0:	15 82       	std	Z+5, r1	; 0x05
	configTwo = 0;
  f2:	16 82       	std	Z+6, r1	; 0x06
	
	pilt = 0;
  f4:	17 82       	std	Z+7, r1	; 0x07
	piht = 0;
  f6:	10 86       	std	Z+8, r1	; 0x08
	ppers = 0;
  f8:	11 86       	std	Z+9, r1	; 0x09
	apers = 0;
  fa:	df 01       	movw	r26, r30
  fc:	a9 5e       	subi	r26, 0xE9	; 233
  fe:	be 4f       	sbci	r27, 0xFE	; 254
 100:	1c 92       	st	X, r1
	pplen = 0;
 102:	12 86       	std	Z+10, r1	; 0x0a
	ppulse = 0;
 104:	13 86       	std	Z+11, r1	; 0x0b
	ldrive = 0;
 106:	14 86       	std	Z+12, r1	; 0x0c
	pgain = 0;
 108:	15 86       	std	Z+13, r1	; 0x0d
	led_boost = 0;
 10a:	16 86       	std	Z+14, r1	; 0x0e
	pint = 0;
 10c:	17 86       	std	Z+15, r1	; 0x0f
	aint = 0;
 10e:	11 97       	sbiw	r26, 0x01	; 1
 110:	1c 92       	st	X, r1
	gint = 0;
 112:	14 8a       	std	Z+20, r1	; 0x14
	pvalid = 0;
 114:	10 8a       	std	Z+16, r1	; 0x10
	pData = 0;
 116:	11 8a       	std	Z+17, r1	; 0x11
	poffset_ur = 0;
 118:	12 8a       	std	Z+18, r1	; 0x12
	poffset_dl = 0;
 11a:	13 8a       	std	Z+19, r1	; 0x13
	
	
	
	fifoData[128] = {0};
 11c:	a1 58       	subi	r26, 0x81	; 129
 11e:	b1 09       	sbc	r27, r1
 120:	1c 92       	st	X, r1
	gfifolvl = 0;
	gfifo_up[32] = {0};
 122:	91 96       	adiw	r26, 0x21	; 33
 124:	1c 92       	st	X, r1
	gfifo_down[32] = {0};
 126:	90 96       	adiw	r26, 0x20	; 32
 128:	1c 92       	st	X, r1
	gfifo_left[32] = {0};
 12a:	ea 50       	subi	r30, 0x0A	; 10
 12c:	ff 4f       	sbci	r31, 0xFF	; 255
 12e:	10 82       	st	Z, r1
 130:	08 95       	ret

00000132 <_ZN12APDS9960_AVR8i2c_stopEv>:
*
*************************************************************/
void APDS9960_AVR::i2c_stop(void)
{
    // send stop condition 
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 132:	84 e9       	ldi	r24, 0x94	; 148
 134:	80 93 bc 00 	sts	0x00BC, r24
	
	// wait until stop condition is executed and bus released
	while(TWCR & (1<<TWSTO));
 138:	ec eb       	ldi	r30, 0xBC	; 188
 13a:	f0 e0       	ldi	r31, 0x00	; 0
 13c:	80 81       	ld	r24, Z
 13e:	84 fd       	sbrc	r24, 4
 140:	fd cf       	rjmp	.-6      	; 0x13c <_ZN12APDS9960_AVR8i2c_stopEv+0xa>

}// i2c_stop 
 142:	08 95       	ret

00000144 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh>:
}


//I2C Communication
bool APDS9960_AVR::i2c_avr_write_byte_data(uint8_t reg, uint8_t command)
{
 144:	dc 01       	movw	r26, r24
	uint8_t twi_status;		//holds the status of the TWI bus
	

	// send START condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 146:	84 ea       	ldi	r24, 0xA4	; 164
 148:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while (!(TWCR & (1<<TWINT)));
 14c:	ec eb       	ldi	r30, 0xBC	; 188
 14e:	f0 e0       	ldi	r31, 0x00	; 0
 150:	90 81       	ld	r25, Z
 152:	99 23       	and	r25, r25
 154:	ec f7       	brge	.-6      	; 0x150 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh+0xc>

	// check value of TWI Status Register. Mask prescaler bits.
	twi_status = TW_STATUS & 0xF8;//TW_STATUS & 0xF8;
 156:	90 91 b9 00 	lds	r25, 0x00B9
 15a:	98 7f       	andi	r25, 0xF8	; 248
	if ((twi_status != TW_START) && (twi_status != TW_REP_START)) 
 15c:	98 30       	cpi	r25, 0x08	; 8
 15e:	39 f0       	breq	.+14     	; 0x16e <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh+0x2a>
 160:	90 31       	cpi	r25, 0x10	; 16
 162:	29 f0       	breq	.+10     	; 0x16e <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh+0x2a>
	{
		//error_i2c = true;I
		//PORTD |= (1 << PD4);
		i2c_stop();
 164:	cd 01       	movw	r24, r26
 166:	0e 94 99 00 	call	0x132	; 0x132 <_ZN12APDS9960_AVR8i2c_stopEv>
		return false;
 16a:	80 e0       	ldi	r24, 0x00	; 0
 16c:	08 95       	ret
	}
	
	// send device slave-address
	TWDR = (APDS9960_I2C_ADDR<<1) | TW_WRITE;
 16e:	82 e7       	ldi	r24, 0x72	; 114
 170:	80 93 bb 00 	sts	0x00BB, r24
	//TWDR = (APDS9960_I2C_ADDR+TW_WRITE);
	TWCR = (1<<TWINT) | (1<<TWEN);
 174:	84 e8       	ldi	r24, 0x84	; 132
 176:	80 93 bc 00 	sts	0x00BC, r24

	// wail until transmission completed and ACK/NACK has been received
	while(!(TWCR & (1<<TWINT)));
 17a:	ec eb       	ldi	r30, 0xBC	; 188
 17c:	f0 e0       	ldi	r31, 0x00	; 0
 17e:	90 81       	ld	r25, Z
 180:	99 23       	and	r25, r25
 182:	ec f7       	brge	.-6      	; 0x17e <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh+0x3a>

	// check value of TWI Status Register. Mask prescaler bits.
	twi_status = TW_STATUS & 0xF8;
 184:	90 91 b9 00 	lds	r25, 0x00B9
 188:	98 7f       	andi	r25, 0xF8	; 248
	if (twi_status != TW_MT_SLA_ACK)// || (twi_status != TW_MR_SLA_ACK) )
 18a:	98 31       	cpi	r25, 0x18	; 24
 18c:	29 f0       	breq	.+10     	; 0x198 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh+0x54>
	{
		//error_i2c = true;
		//PORTD |= (1 << PD5);
		i2c_stop();
 18e:	cd 01       	movw	r24, r26
 190:	0e 94 99 00 	call	0x132	; 0x132 <_ZN12APDS9960_AVR8i2c_stopEv>
		return false;
 194:	80 e0       	ldi	r24, 0x00	; 0
 196:	08 95       	ret
	} 

	
	// address register of the previously addressed device
	TWDR = reg;
 198:	60 93 bb 00 	sts	0x00BB, r22
	TWCR = (1<<TWINT) | (1<<TWEN);
 19c:	84 e8       	ldi	r24, 0x84	; 132
 19e:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 1a2:	ec eb       	ldi	r30, 0xBC	; 188
 1a4:	f0 e0       	ldi	r31, 0x00	; 0
 1a6:	90 81       	ld	r25, Z
 1a8:	99 23       	and	r25, r25
 1aa:	ec f7       	brge	.-6      	; 0x1a6 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh+0x62>

	// check value of TWI Status Register. Mask prescaler bits
	twi_status = TW_STATUS & 0xF8;
 1ac:	80 91 b9 00 	lds	r24, 0x00B9
 1b0:	88 7f       	andi	r24, 0xF8	; 248
	if( twi_status != TW_MT_DATA_ACK) 
 1b2:	88 32       	cpi	r24, 0x28	; 40
 1b4:	29 f0       	breq	.+10     	; 0x1c0 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh+0x7c>
	{
		//error_i2c = true;
		//PORTD |= (1 << PD6);
		i2c_stop();
 1b6:	cd 01       	movw	r24, r26
 1b8:	0e 94 99 00 	call	0x132	; 0x132 <_ZN12APDS9960_AVR8i2c_stopEv>
		return false;
 1bc:	80 e0       	ldi	r24, 0x00	; 0
 1be:	08 95       	ret
	}

	
	// send command to the previously addressed register of addressed device
	TWDR = command;
 1c0:	40 93 bb 00 	sts	0x00BB, r20
	TWCR = (1<<TWINT) | (1<<TWEN);
 1c4:	84 e8       	ldi	r24, 0x84	; 132
 1c6:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 1ca:	ec eb       	ldi	r30, 0xBC	; 188
 1cc:	f0 e0       	ldi	r31, 0x00	; 0
 1ce:	90 81       	ld	r25, Z
 1d0:	99 23       	and	r25, r25
 1d2:	ec f7       	brge	.-6      	; 0x1ce <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh+0x8a>

	// check value of TWI Status Register. Mask prescaler bits
	twi_status = TW_STATUS & 0xF8;
 1d4:	80 91 b9 00 	lds	r24, 0x00B9
 1d8:	88 7f       	andi	r24, 0xF8	; 248
	if( twi_status != TW_MT_DATA_ACK)
 1da:	88 32       	cpi	r24, 0x28	; 40
 1dc:	29 f0       	breq	.+10     	; 0x1e8 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh+0xa4>
	{
		//error_i2c = true;
		//PORTD |= (1 << PD7);
		i2c_stop();
 1de:	cd 01       	movw	r24, r26
 1e0:	0e 94 99 00 	call	0x132	; 0x132 <_ZN12APDS9960_AVR8i2c_stopEv>
		return false;
 1e4:	80 e0       	ldi	r24, 0x00	; 0
 1e6:	08 95       	ret
	}
	
	error_i2c = false;
 1e8:	1c 92       	st	X, r1
	i2c_stop();
 1ea:	cd 01       	movw	r24, r26
 1ec:	0e 94 99 00 	call	0x132	; 0x132 <_ZN12APDS9960_AVR8i2c_stopEv>
	return true;	
 1f0:	81 e0       	ldi	r24, 0x01	; 1
}
 1f2:	08 95       	ret

000001f4 <_ZN12APDS9960_AVR12set_power_onEv>:
}
	
	
bool APDS9960_AVR::set_power_on()
{
	if(!i2c_avr_write_byte_data(APDS9960_ENABLE, ENABLE_POWERON))
 1f4:	41 e0       	ldi	r20, 0x01	; 1
 1f6:	60 e8       	ldi	r22, 0x80	; 128
 1f8:	0e 94 a2 00 	call	0x144	; 0x144 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh>
	}
	else
	{
		return true;
	}	
}
 1fc:	08 95       	ret

000001fe <_ZN12APDS9960_AVR8set_piltEh>:
//---------------------------------------------------------------------------------------/	

//Sets the Proximity Interrupt Low Threshold
//Register 0x89 <7:0>
bool APDS9960_AVR::set_pilt(uint8_t _pilt)
{
 1fe:	46 2f       	mov	r20, r22
	pilt = _pilt;
 200:	fc 01       	movw	r30, r24
 202:	67 83       	std	Z+7, r22	; 0x07
	if(!i2c_avr_write_byte_data(APDS9960_PILT, pilt))
 204:	69 e8       	ldi	r22, 0x89	; 137
 206:	0e 94 a2 00 	call	0x144	; 0x144 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh>
	}
	else
	{
		return true;
	}
}
 20a:	08 95       	ret

0000020c <_ZN12APDS9960_AVR8set_pihtEh>:


//Sets the Proximity Interrupt High Threshold
//Register 0x8B <7:0>
bool APDS9960_AVR::set_piht(uint8_t _piht)
{
 20c:	46 2f       	mov	r20, r22
	piht = _piht;
 20e:	fc 01       	movw	r30, r24
 210:	60 87       	std	Z+8, r22	; 0x08
	if(!i2c_avr_write_byte_data(APDS9960_PIHT, piht))
 212:	6b e8       	ldi	r22, 0x8B	; 139
 214:	0e 94 a2 00 	call	0x144	; 0x144 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh>
	}
	else
	{
		return true;
	}
}
 218:	08 95       	ret

0000021a <_ZN12APDS9960_AVR8set_pienEv>:
}


bool APDS9960_AVR::set_pien()
{
	if(!i2c_avr_write_byte_data(APDS9960_ENABLE, ENABLE_PROX_INT))
 21a:	45 e2       	ldi	r20, 0x25	; 37
 21c:	60 e8       	ldi	r22, 0x80	; 128
 21e:	0e 94 a2 00 	call	0x144	; 0x144 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh>
	{
		return false;
	}
	
	return true;
}
 222:	08 95       	ret

00000224 <_ZN12APDS9960_AVR10clear_pintEv>:
}


bool APDS9960_AVR::clear_pint()
{
	if(!i2c_avr_write_byte_data(APDS9960_PICLEAR, 0xFF))
 224:	4f ef       	ldi	r20, 0xFF	; 255
 226:	65 ee       	ldi	r22, 0xE5	; 229
 228:	0e 94 a2 00 	call	0x144	; 0x144 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh>
	{
		return false;
	}
	
	return true;
}
 22c:	08 95       	ret

0000022e <_ZN12APDS9960_AVR14set_pulseCountEv>:

//Sets the IR-LED pulse length <7:6> and number of pulses <5:0>
//Register 0x8E
bool APDS9960_AVR::set_pulseCount()
{
	if(!i2c_avr_write_byte_data(APDS9960_PPULSE, DEFAULT_PPULSE))
 22e:	40 e9       	ldi	r20, 0x90	; 144
 230:	6e e8       	ldi	r22, 0x8E	; 142
 232:	0e 94 a2 00 	call	0x144	; 0x144 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh>
	else
	{
		return true;
	}
		
}
 236:	08 95       	ret

00000238 <_ZN12APDS9960_AVR22set_ControlRegisterOneEv>:
	
//Sets the IR-LED current <7:6> and Proximity Gain <3:2>	
//Register 0x8F
bool APDS9960_AVR::set_ControlRegisterOne()
{
	if(!i2c_avr_write_byte_data(APDS9960_CONTROL, DEFAULT_CONTROL))
 238:	48 e0       	ldi	r20, 0x08	; 8
 23a:	6f e8       	ldi	r22, 0x8F	; 143
 23c:	0e 94 a2 00 	call	0x144	; 0x144 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh>
	}
	else
	{
		return true;
	}
}
 240:	08 95       	ret

00000242 <_ZN12APDS9960_AVR21set_ConfigRegisterTwoEv>:
	
//Sets the IR-LED Boost <5:4>
//Register 0x90	
bool APDS9960_AVR::set_ConfigRegisterTwo()
{
	if(!i2c_avr_write_byte_data(APDS9960_CONFIG2, DEFAULT_CONFIG2))
 242:	40 e3       	ldi	r20, 0x30	; 48
 244:	60 e9       	ldi	r22, 0x90	; 144
 246:	0e 94 a2 00 	call	0x144	; 0x144 <_ZN12APDS9960_AVR23i2c_avr_write_byte_dataEhh>
	}
	else
	{
		return true;
	}
}
 24a:	08 95       	ret

0000024c <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh>:
	return true;	
}
	
	
uint8_t APDS9960_AVR::i2c_avr_read_byte_data(uint8_t reg)
{
 24c:	1f 93       	push	r17
 24e:	cf 93       	push	r28
 250:	df 93       	push	r29
 252:	ec 01       	movw	r28, r24
 254:	16 2f       	mov	r17, r22
	uint8_t twi_status;			//holds the status of the TWI bus
	uint8_t reg_value = 0;		//holds the data(s) provided by the APDS-9960 Slave
	

	// send START condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 256:	84 ea       	ldi	r24, 0xA4	; 164
 258:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 25c:	ec eb       	ldi	r30, 0xBC	; 188
 25e:	f0 e0       	ldi	r31, 0x00	; 0
 260:	90 81       	ld	r25, Z
 262:	99 23       	and	r25, r25
 264:	ec f7       	brge	.-6      	; 0x260 <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh+0x14>

	// check value of TWI Status Register. Mask prescaler bits.
	twi_status = TW_STATUS & 0xF8;
 266:	80 91 b9 00 	lds	r24, 0x00B9
 26a:	88 7f       	andi	r24, 0xF8	; 248
	if(twi_status != TW_START)
 26c:	88 30       	cpi	r24, 0x08	; 8
 26e:	29 f0       	breq	.+10     	; 0x27a <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh+0x2e>
	{
		error_i2c = true;
 270:	81 e0       	ldi	r24, 0x01	; 1
 272:	88 83       	st	Y, r24
		i2c_stop();
 274:	ce 01       	movw	r24, r28
 276:	0e 94 99 00 	call	0x132	; 0x132 <_ZN12APDS9960_AVR8i2c_stopEv>
	}
		

	// send device slave-address + WRITE-BIT
	TWDR = (APDS9960_I2C_ADDR<<1) | TW_WRITE;
 27a:	82 e7       	ldi	r24, 0x72	; 114
 27c:	80 93 bb 00 	sts	0x00BB, r24
	TWCR = (1<<TWINT) | (1<<TWEN);
 280:	84 e8       	ldi	r24, 0x84	; 132
 282:	80 93 bc 00 	sts	0x00BC, r24

	// wail until transmission completed and ACK/NACK has been received
	while(!(TWCR & (1<<TWINT)));
 286:	ec eb       	ldi	r30, 0xBC	; 188
 288:	f0 e0       	ldi	r31, 0x00	; 0
 28a:	90 81       	ld	r25, Z
 28c:	99 23       	and	r25, r25
 28e:	ec f7       	brge	.-6      	; 0x28a <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh+0x3e>

	// check value of TWI Status Register. Mask prescaler bits.
	twi_status = TW_STATUS & 0xF8;
 290:	80 91 b9 00 	lds	r24, 0x00B9
 294:	88 7f       	andi	r24, 0xF8	; 248
	if(twi_status != TW_MT_SLA_ACK)
 296:	88 31       	cpi	r24, 0x18	; 24
 298:	29 f0       	breq	.+10     	; 0x2a4 <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh+0x58>
	{
		error_i2c = true;
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	88 83       	st	Y, r24
		i2c_stop();
 29e:	ce 01       	movw	r24, r28
 2a0:	0e 94 99 00 	call	0x132	; 0x132 <_ZN12APDS9960_AVR8i2c_stopEv>
	} 

	
	// send register address of slave addressed before
	TWDR = reg;
 2a4:	10 93 bb 00 	sts	0x00BB, r17
	TWCR = (1<<TWINT) | (1<<TWEN);
 2a8:	84 e8       	ldi	r24, 0x84	; 132
 2aa:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 2ae:	ec eb       	ldi	r30, 0xBC	; 188
 2b0:	f0 e0       	ldi	r31, 0x00	; 0
 2b2:	90 81       	ld	r25, Z
 2b4:	99 23       	and	r25, r25
 2b6:	ec f7       	brge	.-6      	; 0x2b2 <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh+0x66>

	// check value of TWI Status Register. Mask prescaler bits
	twi_status = TW_STATUS & 0xF8;
 2b8:	80 91 b9 00 	lds	r24, 0x00B9
 2bc:	88 7f       	andi	r24, 0xF8	; 248
	if(twi_status != TW_MT_DATA_ACK) 
 2be:	88 32       	cpi	r24, 0x28	; 40
 2c0:	29 f0       	breq	.+10     	; 0x2cc <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh+0x80>
	{
		error_i2c = true;
 2c2:	81 e0       	ldi	r24, 0x01	; 1
 2c4:	88 83       	st	Y, r24
		i2c_stop();
 2c6:	ce 01       	movw	r24, r28
 2c8:	0e 94 99 00 	call	0x132	; 0x132 <_ZN12APDS9960_AVR8i2c_stopEv>
	}

	
	// send repeated START-condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 2cc:	84 ea       	ldi	r24, 0xA4	; 164
 2ce:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 2d2:	ec eb       	ldi	r30, 0xBC	; 188
 2d4:	f0 e0       	ldi	r31, 0x00	; 0
 2d6:	90 81       	ld	r25, Z
 2d8:	99 23       	and	r25, r25
 2da:	ec f7       	brge	.-6      	; 0x2d6 <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh+0x8a>

	// check value of TWI Status Register. Mask prescaler bits.
	twi_status = TW_STATUS & 0xF8;
 2dc:	80 91 b9 00 	lds	r24, 0x00B9
 2e0:	88 7f       	andi	r24, 0xF8	; 248
	if (twi_status != TW_REP_START)
 2e2:	80 31       	cpi	r24, 0x10	; 16
 2e4:	29 f0       	breq	.+10     	; 0x2f0 <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh+0xa4>
	{
		error_i2c = true;
 2e6:	81 e0       	ldi	r24, 0x01	; 1
 2e8:	88 83       	st	Y, r24
		i2c_stop();
 2ea:	ce 01       	movw	r24, r28
 2ec:	0e 94 99 00 	call	0x132	; 0x132 <_ZN12APDS9960_AVR8i2c_stopEv>
	}

	
	// send Slave Address + Read-Bit
	TWDR = (APDS9960_I2C_ADDR<<1) | TW_READ;
 2f0:	83 e7       	ldi	r24, 0x73	; 115
 2f2:	80 93 bb 00 	sts	0x00BB, r24
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
 2f6:	84 ec       	ldi	r24, 0xC4	; 196
 2f8:	80 93 bc 00 	sts	0x00BC, r24

	// wail until transmission completed and ACK/NACK has been received
	while(!(TWCR & (1<<TWINT)));
 2fc:	ec eb       	ldi	r30, 0xBC	; 188
 2fe:	f0 e0       	ldi	r31, 0x00	; 0
 300:	90 81       	ld	r25, Z
 302:	99 23       	and	r25, r25
 304:	ec f7       	brge	.-6      	; 0x300 <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh+0xb4>

	// check value of TWI Status Register. Mask prescaler bits.
	twi_status = TW_STATUS & 0xF8;
 306:	80 91 b9 00 	lds	r24, 0x00B9
 30a:	88 7f       	andi	r24, 0xF8	; 248
	if(twi_status != TW_MR_SLA_ACK)
 30c:	80 34       	cpi	r24, 0x40	; 64
 30e:	29 f0       	breq	.+10     	; 0x31a <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh+0xce>
	{
		error_i2c = true;
 310:	81 e0       	ldi	r24, 0x01	; 1
 312:	88 83       	st	Y, r24
		i2c_stop();
 314:	ce 01       	movw	r24, r28
 316:	0e 94 99 00 	call	0x132	; 0x132 <_ZN12APDS9960_AVR8i2c_stopEv>
	} 

	
	//Read one byte from Slave's register addressed before
	TWCR = (1<<TWINT) | (1<<TWEN);
 31a:	84 e8       	ldi	r24, 0x84	; 132
 31c:	80 93 bc 00 	sts	0x00BC, r24
	while(!(TWCR & (1<<TWINT)));
 320:	ec eb       	ldi	r30, 0xBC	; 188
 322:	f0 e0       	ldi	r31, 0x00	; 0
 324:	90 81       	ld	r25, Z
 326:	99 23       	and	r25, r25
 328:	ec f7       	brge	.-6      	; 0x324 <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh+0xd8>
	
	reg_value = TWDR;
 32a:	80 91 bb 00 	lds	r24, 0x00BB
	error_i2c = false;	
 32e:	18 82       	st	Y, r1
	return reg_value;	
}
 330:	df 91       	pop	r29
 332:	cf 91       	pop	r28
 334:	1f 91       	pop	r17
 336:	08 95       	ret

00000338 <_ZN12APDS9960_AVR12getProximityEv>:



//Read out Proximity value
uint8_t APDS9960_AVR::getProximity()
{
 338:	cf 93       	push	r28
 33a:	df 93       	push	r29
 33c:	ec 01       	movw	r28, r24
	pData = i2c_avr_read_byte_data(APDS9960_PDATA);
 33e:	6c e9       	ldi	r22, 0x9C	; 156
 340:	0e 94 26 01 	call	0x24c	; 0x24c <_ZN12APDS9960_AVR22i2c_avr_read_byte_dataEh>
 344:	89 8b       	std	Y+17, r24	; 0x11
	
	return pData;
}	
 346:	df 91       	pop	r29
 348:	cf 91       	pop	r28
 34a:	08 95       	ret

0000034c <__vector_4>:

volatile uint8_t interrupt = 0;


ISR(INT3_vect)
{
 34c:	1f 92       	push	r1
 34e:	0f 92       	push	r0
 350:	0f b6       	in	r0, 0x3f	; 63
 352:	0f 92       	push	r0
 354:	11 24       	eor	r1, r1
 356:	8f 93       	push	r24
	cli();							// disable global interrupts	
 358:	f8 94       	cli
	interrupt = 1;					// interrupt event happening	
 35a:	81 e0       	ldi	r24, 0x01	; 1
 35c:	80 93 00 01 	sts	0x0100, r24
}
 360:	8f 91       	pop	r24
 362:	0f 90       	pop	r0
 364:	0f be       	out	0x3f, r0	; 63
 366:	0f 90       	pop	r0
 368:	1f 90       	pop	r1
 36a:	18 95       	reti

0000036c <main>:


int main(void)
{
 36c:	cf 93       	push	r28
 36e:	df 93       	push	r29
 370:	cd b7       	in	r28, 0x3d	; 61
 372:	de b7       	in	r29, 0x3e	; 62
 374:	c9 51       	subi	r28, 0x19	; 25
 376:	d1 40       	sbci	r29, 0x01	; 1
 378:	0f b6       	in	r0, 0x3f	; 63
 37a:	f8 94       	cli
 37c:	de bf       	out	0x3e, r29	; 62
 37e:	0f be       	out	0x3f, r0	; 63
 380:	cd bf       	out	0x3d, r28	; 61
	//LED outputs
	DDRD |= (1 << DDD6) | (1 << DDD7);		// Pins PD6 and PD7 as OUTPUT for LEDs
 382:	8a b1       	in	r24, 0x0a	; 10
 384:	80 6c       	ori	r24, 0xC0	; 192
 386:	8a b9       	out	0x0a, r24	; 10
	PORTD &= ~((1 << PD6) | (1 << PD7));	// On beginning both LEDs turned OFF
 388:	8b b1       	in	r24, 0x0b	; 11
 38a:	8f 73       	andi	r24, 0x3F	; 63
 38c:	8b b9       	out	0x0b, r24	; 11

	//Interrupt setup	
	DDRD &= ~(1 << DDD3);			// input pin
 38e:	53 98       	cbi	0x0a, 3	; 10
	PORTD &= ~(1 << PD3);			// activate internal pull-up
 390:	5b 98       	cbi	0x0b, 3	; 11
	EICRA &= ~(1 << ISC30);			// interrupt detected
 392:	e9 e6       	ldi	r30, 0x69	; 105
 394:	f0 e0       	ldi	r31, 0x00	; 0
 396:	80 81       	ld	r24, Z
 398:	8f 7b       	andi	r24, 0xBF	; 191
 39a:	80 83       	st	Z, r24
	EICRA |= (1 << ISC31);			// on falling edge
 39c:	80 81       	ld	r24, Z
 39e:	80 68       	ori	r24, 0x80	; 128
 3a0:	80 83       	st	Z, r24
	EIMSK = (1 << INT3);			// enable external interrupt on INT3 pin PD3
 3a2:	88 e0       	ldi	r24, 0x08	; 8
 3a4:	8d bb       	out	0x1d, r24	; 29
	
	cli();							// before program starts make sure no interrupt is happening
 3a6:	f8 94       	cli
	
	// APDS-9960 initialization	
	APDS9960_AVR sensor = APDS9960_AVR();
 3a8:	ce 01       	movw	r24, r28
 3aa:	01 96       	adiw	r24, 0x01	; 1
 3ac:	0e 94 6a 00 	call	0xd4	; 0xd4 <_ZN12APDS9960_AVRC1Ev>
	sensor.set_power_on();
 3b0:	ce 01       	movw	r24, r28
 3b2:	01 96       	adiw	r24, 0x01	; 1
 3b4:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <_ZN12APDS9960_AVR12set_power_onEv>
	sensor.set_pulseCount();			// Pulselength (PPLEN) and number (PPULSE) of radiated IR-beam pulses
 3b8:	ce 01       	movw	r24, r28
 3ba:	01 96       	adiw	r24, 0x01	; 1
 3bc:	0e 94 17 01 	call	0x22e	; 0x22e <_ZN12APDS9960_AVR14set_pulseCountEv>
	sensor.set_ControlRegisterOne();	// LED drive strength (LDRIVE 7:6), Proximity Gain Control (PGAIN 3:2)
 3c0:	ce 01       	movw	r24, r28
 3c2:	01 96       	adiw	r24, 0x01	; 1
 3c4:	0e 94 1c 01 	call	0x238	; 0x238 <_ZN12APDS9960_AVR22set_ControlRegisterOneEv>
	sensor.set_ConfigRegisterTwo();		// Additional LED drive current (LED_BOOST) during proximity LED pulses
 3c8:	ce 01       	movw	r24, r28
 3ca:	01 96       	adiw	r24, 0x01	; 1
 3cc:	0e 94 21 01 	call	0x242	; 0x242 <_ZN12APDS9960_AVR21set_ConfigRegisterTwoEv>
	sensor.set_piht(DEFAULT_PIHT);		// Proximity Interrupt High Threshold
 3d0:	62 e3       	ldi	r22, 0x32	; 50
 3d2:	ce 01       	movw	r24, r28
 3d4:	01 96       	adiw	r24, 0x01	; 1
 3d6:	0e 94 06 01 	call	0x20c	; 0x20c <_ZN12APDS9960_AVR8set_pihtEh>
	sensor.set_pilt(DEFAULT_PILT);		// Proximity Interrupt Low Threshold
 3da:	60 e0       	ldi	r22, 0x00	; 0
 3dc:	ce 01       	movw	r24, r28
 3de:	01 96       	adiw	r24, 0x01	; 1
 3e0:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN12APDS9960_AVR8set_piltEh>
	sensor.set_pien();					//enable Proximity Detection and Proximity Interrupt
 3e4:	ce 01       	movw	r24, r28
 3e6:	01 96       	adiw	r24, 0x01	; 1
 3e8:	0e 94 0d 01 	call	0x21a	; 0x21a <_ZN12APDS9960_AVR8set_pienEv>
	
	sei();								// activate global interrupts
 3ec:	78 94       	sei
	uint8_t prox = 0;
	uint8_t max_piht = 0;
 3ee:	10 e0       	ldi	r17, 0x00	; 0
			{
				PORTD |= (1 << PD7);
				PORTD &= ~(1 << PD6);
				sensor.set_piht(MAX_PIHT);
				sensor.set_pilt(HYST_PILT);
				max_piht = 1;
 3f0:	01 e0       	ldi	r16, 0x01	; 1
	uint8_t max_piht = 0;
	
	
    while (1) 
    {
		if(interrupt)
 3f2:	80 91 00 01 	lds	r24, 0x0100
 3f6:	88 23       	and	r24, r24
 3f8:	e1 f3       	breq	.-8      	; 0x3f2 <main+0x86>
		{
			prox = sensor.getProximity();
 3fa:	ce 01       	movw	r24, r28
 3fc:	01 96       	adiw	r24, 0x01	; 1
 3fe:	0e 94 9c 01 	call	0x338	; 0x338 <_ZN12APDS9960_AVR12getProximityEv>
			// if PDATA exceeds DEFAULT_PIHT, turn ON LED green and set PIHT to maximum
			if((prox > DEFAULT_PIHT) && (!max_piht))
 402:	83 33       	cpi	r24, 0x33	; 51
 404:	80 f0       	brcs	.+32     	; 0x426 <main+0xba>
 406:	11 11       	cpse	r17, r1
 408:	27 c0       	rjmp	.+78     	; 0x458 <main+0xec>
			{
				PORTD |= (1 << PD7);
 40a:	5f 9a       	sbi	0x0b, 7	; 11
				PORTD &= ~(1 << PD6);
 40c:	5e 98       	cbi	0x0b, 6	; 11
				sensor.set_piht(MAX_PIHT);
 40e:	6f ef       	ldi	r22, 0xFF	; 255
 410:	ce 01       	movw	r24, r28
 412:	01 96       	adiw	r24, 0x01	; 1
 414:	0e 94 06 01 	call	0x20c	; 0x20c <_ZN12APDS9960_AVR8set_pihtEh>
				sensor.set_pilt(HYST_PILT);
 418:	62 e3       	ldi	r22, 0x32	; 50
 41a:	ce 01       	movw	r24, r28
 41c:	01 96       	adiw	r24, 0x01	; 1
 41e:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN12APDS9960_AVR8set_piltEh>
				max_piht = 1;
 422:	10 2f       	mov	r17, r16
 424:	11 c0       	rjmp	.+34     	; 0x448 <main+0xdc>
				
			}
			else if((prox < DEFAULT_PIHT) && (max_piht))
 426:	82 33       	cpi	r24, 0x32	; 50
 428:	78 f4       	brcc	.+30     	; 0x448 <main+0xdc>
 42a:	11 23       	and	r17, r17
 42c:	69 f0       	breq	.+26     	; 0x448 <main+0xdc>
			{
				max_piht = 0;
				PORTD &= ~(1 << PD7);
 42e:	5f 98       	cbi	0x0b, 7	; 11
				PORTD |= (1 << PD6);
 430:	5e 9a       	sbi	0x0b, 6	; 11
				sensor.set_piht(DEFAULT_PIHT);
 432:	62 e3       	ldi	r22, 0x32	; 50
 434:	ce 01       	movw	r24, r28
 436:	01 96       	adiw	r24, 0x01	; 1
 438:	0e 94 06 01 	call	0x20c	; 0x20c <_ZN12APDS9960_AVR8set_pihtEh>
				sensor.set_pilt(DEFAULT_PILT);
 43c:	60 e0       	ldi	r22, 0x00	; 0
 43e:	ce 01       	movw	r24, r28
 440:	01 96       	adiw	r24, 0x01	; 1
 442:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN12APDS9960_AVR8set_piltEh>
				max_piht = 1;
				
			}
			else if((prox < DEFAULT_PIHT) && (max_piht))
			{
				max_piht = 0;
 446:	10 e0       	ldi	r17, 0x00	; 0
			//_delay_ms(1000);
			//PORTD &= ~((1 << PD6) | (1 << PD7));
		
			
			prox = 0;
			interrupt = 0;
 448:	10 92 00 01 	sts	0x0100, r1
			sensor.clear_pint();
 44c:	ce 01       	movw	r24, r28
 44e:	01 96       	adiw	r24, 0x01	; 1
 450:	0e 94 12 01 	call	0x224	; 0x224 <_ZN12APDS9960_AVR10clear_pintEv>
			sei();
 454:	78 94       	sei
 456:	cd cf       	rjmp	.-102    	; 0x3f2 <main+0x86>
				sensor.set_piht(MAX_PIHT);
				sensor.set_pilt(HYST_PILT);
				max_piht = 1;
				
			}
			else if((prox < DEFAULT_PIHT) && (max_piht))
 458:	82 33       	cpi	r24, 0x32	; 50
 45a:	48 f3       	brcs	.-46     	; 0x42e <main+0xc2>
 45c:	f5 cf       	rjmp	.-22     	; 0x448 <main+0xdc>

0000045e <_exit>:
 45e:	f8 94       	cli

00000460 <__stop_program>:
 460:	ff cf       	rjmp	.-2      	; 0x460 <__stop_program>
